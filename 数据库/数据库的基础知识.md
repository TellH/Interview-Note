## 什么是事务？

事务（Transaction）是**并发控制的基本单位**。所谓的事务，它是一个操作序列，这些操作要么都执行，要么都不执行，它是一个不可分割的工作单位。事务是数据库维护数据一致性的单位，在每个事务结束时，都能保持数据一致性。

## 事务的特性

1. 原子性 Atomicity：当你对数据有任何操作的时候，所有的操作需要都成功反之则全不成功。
2. 一致性 Consistency：一致性,即在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏，使得系统从一个一致的状态转换到另一个一致状态。
3. 隔离性 Isolation：并发的事务是相互隔离的，互不影响的。
4. 持久性 Durability：当系统或介质发生故障时，确保已提交事务的更新不能丢失。



## 事务的隔离界别

### 脏读，不可重复读，幻读

**脏读**：一个事务读取到另一事务未提交的更新新据。当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有
提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据， 那么另
外一个事务读到的这个数据是脏数据，依据脏数据所做的操作也可能是不正确的。

**不可重复读**：在同一事务中，多次读取同一数据返回的结果有所不同。换句话说就是，后续读取可以读到另一事务已提交的
更新数据。相反，“可重复读”在同一事务中多次读取数据时，能够保证所读数据一样，也就是，后续读取不能读到另一事务
已提交的更新数据。

**幻读**：事务T1执行一次查询，然后事务T2新插入一行记录，这行记录恰好可以满足T1所使用的查询的条件。然后T1又使用相同的查询再次对表进行检索，但是此时却看到了事务T2刚才插入的新行。这个新行就称为“幻像”，因为对T1来说这一行就像突然出现的一样。

### 隔离级别

1. ISOLATION_READ_UNCOMMITTED：在并发的事务中，它充许一个事务可以读到另一个事务未提交的更新数据。（会出现脏读，不可重复读和幻读）
2. ISOLATION_READ_COMMITTED：读已提交数据，保证在并发的事务中，一个事务修改的数据提交后才能被另外一个事务读取到。但其他事务可以在当前事务未提交前更新或插入数据。（会出现不可重复读和幻读）
3. ISOLATION_REPEATABLE_READ：规定在当前事务提交之前其他事务不能对数据库进行update操作，防止了不可重复读，但不能避免有幻读。
4. ISOLATION_SERIALIZABLE：最严的事务隔离界别，规定事务之间的执行时串行执行的。



## 数据库范式

1NF：字段是最小的的单元不可再分 
2NF：满足1NF,表中的字段必须完全依赖于全部主键而非部分主键，消除非主属性对码的部分依赖
3NF：满足2NF,非主键外的所有字段必须互不依赖，消除非主属性对码的传递依赖
BCNF: 消除主属性对码的部分依赖和传递依赖。

## 索引是什么？作用以及优缺点？

索引是对数据库表中一或多个列的值进行排序的结构，能加快数据的检索。

**MySQL**数据库几个基本的索引类型：普通索引、唯一索引、主键索引、全文索引

- 主键索引

一种特殊的唯一索引，不允许有空值。

- 唯一索引

唯一索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。

- 全文索引

广泛应用于搜索引擎。

作用以及优缺点：

- 索引加快数据库的检索速度
- 索引增加了插入、删除、修改等维护任务的时间开销
- 唯一索引可以确保每一行数据的唯一性
- 通过使用索引，可以在查询的过程中使用优化隐藏器，提高系统的性能
- 索引需要占物理和数据空间 
- 每当有记录在表中增减或索引列被修改时,索引本身也会被修改

参考：[MySQL索引及查询优化总结](http://blog.csdn.net/qcloudcommunity/article/details/71227006)

## 数据库的乐观锁和悲观锁

乐观并发控制(乐观锁)和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。

- 悲观锁：假定会发生并发冲突，在对任意记录进行修改前，先尝试为该记录加上排他锁。
- 乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性（利用数据库版本号或时间戳）。

### 悲观锁

悲观并发控制实际上是“先取锁再访问”的保守策略。在效率方面，处理加锁的机制会让数据库产生额外的开销，还有增加产生死锁的机会；另外，在只读型事务处理中由于不会产生冲突，也没必要使用锁，这样做只能增加系统负载；还有会降低了并行性，一个事务如果锁定了某行数据，其他事务就必须等待该事务处理完才可以处理那行数。

适用于数据争用激烈的环境，以及发生并发冲突时使用锁保护数据的成本要低于回滚事务的成本的环境中。

### 乐观锁

乐观并发控制相信事务之间的数据竞争(data race)的概率是比较小的，直到提交的时候才去锁定，所以不会产生任何锁和死锁。但一旦事务回滚的成本太高会影响效率。

参考：http://www.open-open.com/lib/view/open1452046967245.html

## **drop、delete**与**truncate**的区别

- **delete和truncate**只删除表的数据不删除表的结构，**drop**则删除整个表（结构和数据）
- 速度,一般来说: drop> truncate >delete
- truncate和drop是DDL，会隐式提交，所以，不能回滚，不会触发触发器。
- truncate会删除表中所有记录。
- delete是DML，执行delete操作时，每次从表中删除一行，并且同时将该行的的删除操作记录在redo和undo表空间中以便进行回滚（rollback）和重做操作，但要注意表空间要足够大，需要手动提交（commit）操作才能生效，可以通过rollback撤消操作。

参考：http://blog.csdn.net/ws0513/article/details/49980547

## 什么是视图

视图是一种**虚拟的表**，具有和物理表相同的功能。可以对视图进行增，改，查，操作，试图通常是有**一个表或者多个表的行或列的子集**。对视图的修改不影响基本表。它使得我们获取数据更容易，相比多表查询。

参考：https://zhuanlan.zhihu.com/p/23713529

## SQL查询语句的执行数据

```sql
(7)     SELECT 
(8)     DISTINCT <select_list>
(1)     FROM <left_table>
(3)     <join_type> JOIN <right_table>
(2)     ON <join_condition>
(4)     WHERE <where_condition>
(5)     GROUP BY <group_by_list>
(6)     HAVING <having_condition>
(9)     ORDER BY <order_by_condition>
(10)    LIMIT <limit_number>
```

1. 利用FROM子句确定查询的是哪张表
2. 利用ON确定连接条件
3. 确定连接方式，是左外连接还是右外连接
4. 利用WHERE子句筛选元组
5. 利用GROUP BY子句对筛选后的元组进行分组
6. 利用HAVING子句筛选分组
7. 执行SELECT子句，挑选需要的属性列
8. 利用DISTINCT子句过滤重复的元组
9. 利用ORDER BY子句对元组进行排序
10. 执行LIMIT子句进行分页


## 如何判定是否需要创建索引

1. 较频繁地作为查询条件的字段应该创建索引
2. 唯一性太差字段不适合单独创建索引
3. 更新非常频繁的字段不适合创建索引
4. 不会出现在where子句中的字段不需要创建索引

## 复合索引

索引可以包含一个、两个或更多个列。两个或更多个列上的索引被称作复合索引。

利用索引中的附加列，您可以缩小搜索的范围，但使用一个具有两列的索引不同于使用两个单独的索引。复合索引的结构与电话簿类似，人名由姓和名构成，电话簿首先按姓氏对进行排序，然后按名字对有相同姓氏的人进行排序。如果您知道姓，电话簿将非常有用；如果您知道姓和名，电话簿则更为有用，但如果您只知道名不姓，电话簿将没有用处。

**查询优化器在在where查询中的作用：**

1. 如果一个多列索引存在于 列 Col1 和 Col2 上，

则以下语句：Select   * from table where   col1=val1 AND col2=val2 
查询优化器会试图通过决定哪个索引将找到更少的行。之后用得到的索引去取值。

2. 如果存在一个多列索引，任何最左面的索引前缀能被优化器使用。所以联合索引的顺序不同，影响索引的选择，尽量将值少的放在前面。

如：一个多列索引为 (col1 ，col2， col3)
​    那么在索引在列 (col1) 、(col1 col2) 、(col1 col2 col3) 的搜索会有作用。

```sql
SELECT * FROM tb WHERE  col1 = val1
SELECT * FROM tb WHERE  col1 = val1 and col2 = val2
SELECT * FROM tb WHERE  col1 = val1 and col2 = val2  AND col3 = val3
```

3. 如果列不构成索引的**最左面前缀**，则建立的索引将不起作用。

```sql
SELECT * FROM  tb WHERE  col3 = val3
SELECT * FROM  tb  WHERE  col2 = val2
SELECT * FROM  tb  WHERE  col2 = val2  and  col3=val3
```

4. 如果一个 Like 语句的查询条件不以通配符起始则使用索引。

如：%车 或 %车%   不使用索引。
​    车%              使用索引。

**一些常见的索引限制问题：**

1. 使用不等于操作符(<>, !=)。

通过把用 or 语法替代不等号进行查询，就可以使用索引，以避免全表扫描：上面的语句改成下面这样的，就可以使用索引了。

```sql
select * from dept shere staff_num < 1000 or staff_num > 1000;
```

2. 使用 is null 或 is not null

