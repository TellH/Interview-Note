### 智能指针的实现原理

智能指针类将一个计数器与类指向的对象相关联，通过引用计数法跟踪该类有多少个对象共享同一指针。

1. 重写构造函数。当智能指针类初始化时，初始化内部关联的指针，计数器设为1。
2. 重写复制构造函数。当对象作为另一对象的副本而创建时，拷贝构造函数拷贝指针并增加与之相应的引用计数。
3. 重写赋值运算符。对一个对象进行赋值时，赋值操作符减少左操作数所指对象的引用计数（如果引用计数为减至0，则删除对象），并增加右操作数所指对象的引用计数。
4. 重写析构函数。减少引用计数（如果引用计数减至0，则删除基础对象）。
5. 重写-> 和 * 操作符，让智能指针模拟普通指针的行为。

```c++
#include <iostream>
#include <memory>
template<typename T>
class SmartPointer {
private:
    T* _ptr;
    size_t* _count;
public:
    SmartPointer(T* ptr = nullptr) :
            _ptr(ptr) {
        if (_ptr) {
            _count = new size_t(1);
        } else {
            _count = new size_t(0);
        }
    }
    SmartPointer(const SmartPointer& ptr) {
        if (this != &ptr) {
            this->_ptr = ptr._ptr;
            this->_count = ptr._count;
            (*this->_count)++;
        }
    }
    SmartPointer& operator=(const SmartPointer& ptr) {
        if (this->_ptr == ptr._ptr) {
            return *this;
        }
        if (this->_ptr) {
            (*this->_count)--;
            if (this->_count == 0) {
                delete this->_ptr;
                delete this->_count;
            }
        }
        this->_ptr = ptr._ptr;
        this->_count = ptr._count;
        (*this->_count)++;
        return *this;
    }
    T& operator*() {
        assert(this->_ptr == nullptr);
        return *(this->_ptr);
    }
    T* operator->() {
        assert(this->_ptr == nullptr);
        return this->_ptr;
    }
    ~SmartPointer() {
        (*this->_count)--;
        if (*this->_count == 0) {
            delete this->_ptr;
            delete this->_count;
        }
    }
    size_t use_count(){
        return *this->_count;
    }
};
```

### 如何定义一个只能在堆上（栈上）生成对象的类?

- 只能在堆上创建，将析构函数设为私有
- 只能在栈上创建，将new操作符函数设为私有


### 引用和指针的区别

本质：引用是别名，指针是地址，具体的： 

- 指针可以在运行时改变其所指向的值，引用一旦和某个对象绑定就不再改变 
- 从内存上看，指针会分配内存区域，而引用不会，它仅仅是一个别名 
- 在参数传递时，引⽤用会做类型检查，而指针不会 
- 引用不能为空，指针可以为空

### const和define的区别

本质：define只是字符串替换，const参与编译运行，具体的： 

- const对应编译器；#define对应预处理器


- define不会做类型检查，const拥有类型，会执行相应的类型检查 
- const内存效率更高，编译器通常将const变量保存在符号表中，而不会分配存储空间，这使得它成 为一个编译期间的常量，没有存储和读取的操作

### malloc和new的区别

- malloc与free是C++/C语言的标准库函数，new/delete是C++的运算符。它们都可用于申请动态内存和释放内存。
- new可以认为是malloc加构造函数的执行。new出来的指针是直接带类型信息的。而malloc返回的都是void指针。
- new会先分配内存资源利用operator::new，然后执行构造函数，而malloc不会执行构造函数。

### 虚函数的作用和底层实现

虚函数的作用：实现多态，使基类指针指向派生类对象时，访问派生类的同名函数，实现动态联编。

从C++对象内存模型来看，每个对象的开头部分内存至少有一个指针vfptr，指向一个虚函数表vtable，成员变量根据其继承和声明顺序依次放在后面。虚函数表的每一个表项是父类的虚函数指针（如果自身的类没有复写该虚函数的话），或者是自身的类的函数指针（复写了父类对应的虚函数）。每次通过基类指针调用虚函数，都是通过查找虚函数表最终找到函数指针。子类的成员函数被放到了第一个父类的表中。

在父类构造函数中调用虚函数仍然是父类版本的函数，子类中调用的仍然是子类版本的函数。

参考：

- [C++ 虚函数表解析](http://blog.csdn.net/haoel/article/details/1948051)

- [C++ 对象的内存布局（上）](http://blog.csdn.net/haoel/article/details/3081328)

- [C++ 对象的内存布局（下）](http://blog.csdn.net/haoel/article/details/3081385)

- [图说C++对象模型：对象内存布局详解](http://www.cnblogs.com/QG-whz/p/4909359.html)


### 复制构造函数

在C++中，有以下三种情况需要copy构造函数：

1. 对象以值传递的方式传参
2. 对象以值传递的方式从函数返回
3. 对象需要通过另一个对象进行初始化

### 为什么要内存对齐

在对齐的内存地址上,四字节存取粒度处理器可以一次性的将4个字节全部读出;而在非对齐的内存地址上,读取次数将加倍。

参考：[为什么要内存对齐 Data alignment: Straighten up and fly right](http://blog.csdn.net/lgouc/article/details/8235471)



### list和vector的区别

- vector和数组类似，它拥有一段连续的内存空间，并且起始地址不变，因此它能非常好的支持随机存取（即使用[]操作符访问其中的元素），但由于它的内存空间是连续的，所以在中间进行插入和删除会造成内存块的拷贝（复杂度是O(n)），另外，当该数组后的内存空间不够时，需要重新申请一块足够大的内存并进行内存的拷贝。这些都大大影响了vector的效率。
- list是由数据结构中的双向链表实现的，因此它的内存空间可以是不连续的。因此只能通过指针来进行数据的访问，这个特点使得它的随机存取变的非常没有效率，需要遍历中间的元素，搜索复杂度O(n)，因此它没有提供[]操作符的重载。但由于链表的特点，它可以以很好的效率支持任意地方的删除和插入。


### 虚函数表在内存中的存放位置

在静态存储区。类对象的继承关系在编译时已经能够知道了，因此具体的虚表内容，在编译时就决定了整个继承链上V-table的信息。

### 内存管理

#### 内存分区

- 栈：在执行函数时，函数局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元会被自动释放。对栈的内存分配和释放的相关指令内置于处理器的指令集中，效率很高，但容量有限；
- 堆：那些由 `new`分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个`new`就要对应一个 `delete`。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。
- 全局/静态存储区：全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量又分为初始化的和未初始化的，在C++里面没有这个区分了，他们共同占用同一块内存区。
- 常量存储区：这是一块比较特殊的存储区，他们里面存放的是常量，不允许修改。

#### 堆和栈的区别

- 管理方式的不同。栈是由编译器自动管理的， 无需手工控制；堆的释放工作由程序员负责。
- 碎片问题。频繁的new和delete会造成内存空间的不连续，从而造成大量的碎片。一个防止堆破碎的通用方法是从不同固定大小的内存持中分配不同类型的对象。对每个类重载`new` 和`delete`就提供了这样的控制。
- 分配效率。栈是计算机底层支持的数据结构，压栈和出栈有专门的指令，因此栈的内存分配效率较高。堆的内存分配由C函数库支持，如果堆的碎片太多会大大降低内存分配的效率。

####  野指针的形成

- 指针变量没有初始化，指针变量默认值是随机的，应该初始化为NULL
- 指针被free或delete后没有置为NULL
- 指针操作超越了变量的作用域范围

#### malloc/free VS new/delete

`malloc`与`free`是C++/C语言的标准库函数，`new/delete`是C++的运算符。它们都可用于申请动态内存和释放内存。
对于非内部数据类型的对象而言，光用`maloc/free`无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。由于`malloc/free`是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于`malloc/free`。
因此C++语言需要一个能完成动态内存分配和初始化工作的运算符`new`，以及一个能完成清理与释放内存工作的运算符`delete`。

**参考：** [C/C++内存管理详解](C/C++内存管理详解)

### 用C语言实现memmove函数

```c
/**
使用memmove来进行拷贝要考虑区间重叠问题，否则在拷贝过程中可能造成重叠错误。
针对有可能出现的问题给出了一定的处理措施来防止拷贝出错：
（1）当源内存的首地址等于目标内存的首地址时，不进行任何拷贝
（2）当源内存的首地址大于目标内存的首地址时，实行正向拷贝
（3）当源内存的首地址小于目标内存的首地址时，实 行反向拷贝
 */
void memmove(void *dest, const void *src, int n) {
    if (dest == NULL || src == NULL) return;
    char *p, *q;
    int step;
    if ((char *) dest == (char *) src) {
        return;
    } else if ((char *) dest < (char *) src) {
        step = 1;
        p = src;
        q = dest;
    } else {
        step = -1;
        p = src + n - 1;
        q = dest + n - 1;
    }
    for (int i = 0; i < n; ++i) {
        *q = *p;
        p += step;
        q += step;
    }
}
```

